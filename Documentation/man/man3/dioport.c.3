.TH "DIOPort/dioport.c" 3 "Sun Mar 10 2019" "DIO" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DIOPort/dioport.c
.SH SYNOPSIS
.br
.PP
\fC#include <ntddk\&.h>\fP
.br
\fC#include 'iomap\&.h'\fP
.br
\fC#include '\&.\&./Include/dioctl\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDIO_DENY_CONVENTIONAL_PORT_ACCESS\fP"
.br
.ti -1c
.RI "#define \fBDIO_SUPPORT_UNLOAD\fP"
.br
.ti -1c
.RI "#define \fBDIO_ALLOC\fP(_size)   ExAllocatePoolWithTag(NonPagedPool, (_size), 'OIDp')"
.br
.ti -1c
.RI "#define \fBDIO_FREE\fP(_addr)   ExFreePoolWithTag((_addr), 'OIDp')"
.br
.ti -1c
.RI "#define \fBDIO_TRACE\fP(_fmt, \&.\&.\&.)   DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, (_fmt), __VA_ARGS__)"
.br
.ti -1c
.RI "#define \fBDIO_FUNC_TRACE\fP(_fmt, \&.\&.\&.)   DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, ('%s: ' _fmt), __FUNCTION__, __VA_ARGS__)"
.br
.ti -1c
.RI "#define \fBDIO_IN_DEBUG_BREAKPOINT\fP()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBC_ASSERT\fP (sizeof(PEPROCESS)==4)"
.br
.ti -1c
.RI "BOOLEAN \fBDiopValidatePacketBuffer\fP (IN \fBDIO_PACKET\fP *Packet, IN ULONG InputBufferLength, IN ULONG IoControlCode)"
.br
.RI "Validates the packet buffer\&. "
.ti -1c
.RI "VOID \fBDiopSetIoAccessMap\fP (IN \fBDIO_PORTACCESS_ENTRY\fP *PortAccessEntry, IN \fBIO_ACCESS_MAP\fP *AccessMap, IN BOOLEAN DenyAccess)"
.br
.RI "Sets the I/O access map\&. "
.ti -1c
.RI "VOID \fBDioDenyConventionalPortAccess\fP (IN \fBIO_ACCESS_MAP\fP *AccessMap)"
.br
.RI "Denies the port I/O access for well-known address\&. "
.ti -1c
.RI "BOOLEAN \fBDioSetIoAccessMapByPacket\fP (IN OPTIONAL \fBDIO_PACKET_PORTACCESS\fP *PortAccess, IN \fBIO_ACCESS_MAP\fP *AccessMap)"
.br
.RI "Enables port I/O access for specified address range\&. "
.ti -1c
.RI "BOOLEAN \fBDioRegisterSelf\fP (VOID)"
.br
.RI "Registers caller process to permit port I/O access\&. "
.ti -1c
.RI "BOOLEAN \fBDioUnregister\fP (IN BOOLEAN DisableIoAccess)"
.br
.RI "Unregisters caller process to permit port I/O access\&. "
.ti -1c
.RI "BOOLEAN \fBDioForceUnregister\fP (IN HANDLE UnregisterProcessId)"
.br
.RI "Forcibly unregisters specified process\&. "
.ti -1c
.RI "VOID \fBDiopCreateProcessNotifyRoutine\fP (IN HANDLE ParentId, IN HANDLE ProcessId, IN BOOLEAN Create)"
.br
.RI "Our process notify routine\&. "
.ti -1c
.RI "NTSTATUS \fBDioDispatchNotSupported\fP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"
.br
.RI "Default dispatch routine for not supported functions\&. "
.ti -1c
.RI "NTSTATUS \fBDioDispatchCreate\fP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"
.br
.RI "Dispatch routine for IRP_MJ_CREATE\&. "
.ti -1c
.RI "NTSTATUS \fBDioDispatchClose\fP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"
.br
.RI "Dispatch routine for IRP_MJ_CLOSE\&. "
.ti -1c
.RI "NTSTATUS \fBDioDispatchIoControl\fP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"
.br
.RI "Dispatch routine for IRP_MJ_DEVICE_CONTROL\&. "
.ti -1c
.RI "VOID \fBDioDriverUnload\fP (IN PDRIVER_OBJECT DriverObject)"
.br
.RI "Dispatch routine for DriverUnload\&. "
.ti -1c
.RI "NTSTATUS \fBDriverEntry\fP (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)"
.br
.RI "Driver start entry\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "PDRIVER_OBJECT \fBDiopDriverObject\fP = NULL"
.br
.ti -1c
.RI "PDEVICE_OBJECT \fBDiopDeviceObject\fP = NULL"
.br
.ti -1c
.RI "UNICODE_STRING \fBDiopDeviceName\fP"
.br
.ti -1c
.RI "UNICODE_STRING \fBDiopDosDeviceName\fP"
.br
.ti -1c
.RI "\fBIO_ACCESS_MAP\fP * \fBDiopIoAccessMap\fP = NULL"
.br
.ti -1c
.RI "KSPIN_LOCK \fBDiopForceUnregisterLock\fP"
.br
.ti -1c
.RI "volatile PEPROCESS \fBDiopRegisteredProcess\fP = NULL"
.br
.ti -1c
.RI "\fBDIO_PORTACCESS_ENTRY\fP \fBDiopConventionalPortAccessListForDeny\fP []"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define DIO_ALLOC(_size)   ExAllocatePoolWithTag(NonPagedPool, (_size), 'OIDp')"

.PP
Definition at line 13 of file dioport\&.c\&.
.SS "#define DIO_DENY_CONVENTIONAL_PORT_ACCESS"

.PP
Definition at line 6 of file dioport\&.c\&.
.SS "#define DIO_FREE(_addr)   ExFreePoolWithTag((_addr), 'OIDp')"

.PP
Definition at line 14 of file dioport\&.c\&.
.SS "#define DIO_FUNC_TRACE(_fmt,  \&.\&.\&.)   DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, ('%s: ' _fmt), __FUNCTION__, __VA_ARGS__)"

.PP
Definition at line 17 of file dioport\&.c\&.
.SS "#define DIO_IN_DEBUG_BREAKPOINT()"
\fBValue:\fP
.PP
.nf
{      \
    if (!(*KdDebuggerNotPresent)) {     \
        __debugbreak();                 \
    }                                   \
}
.fi
.PP
Definition at line 19 of file dioport\&.c\&.
.SS "#define DIO_SUPPORT_UNLOAD"

.PP
Definition at line 7 of file dioport\&.c\&.
.SS "#define DIO_TRACE(_fmt,  \&.\&.\&.)   DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, (_fmt), __VA_ARGS__)"

.PP
Definition at line 16 of file dioport\&.c\&.
.SH "Function Documentation"
.PP 
.SS "C_ASSERT (sizeof(PEPROCESS) = \fC=4\fP)"

.SS "VOID DioDenyConventionalPortAccess (IN \fBIO_ACCESS_MAP\fP * AccessMap)"

.PP
Denies the port I/O access for well-known address\&. 
.PP
\fBParameters:\fP
.RS 4
\fIAccessMap\fP Access map to modify\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Definition at line 156 of file dioport\&.c\&.
.SS "NTSTATUS DioDispatchClose (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"

.PP
Dispatch routine for IRP_MJ_CLOSE\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDeviceObject\fP Device object\&. 
.br
\fIIrp\fP Irp object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
STATUS_SUCCESS always\&. 
.RE
.PP

.PP
Definition at line 403 of file dioport\&.c\&.
.SS "NTSTATUS DioDispatchCreate (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"

.PP
Dispatch routine for IRP_MJ_CREATE\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDeviceObject\fP Device object\&. 
.br
\fIIrp\fP Irp object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
STATUS_SUCCESS always\&. 
.RE
.PP

.PP
Definition at line 380 of file dioport\&.c\&.
.SS "NTSTATUS DioDispatchIoControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"

.PP
Dispatch routine for IRP_MJ_DEVICE_CONTROL\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDeviceObject\fP Device object\&. 
.br
\fIIrp\fP Irp object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
STATUS_SUCCESS always\&. 
.RE
.PP

.PP
Definition at line 426 of file dioport\&.c\&.
.SS "NTSTATUS DioDispatchNotSupported (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)"

.PP
Default dispatch routine for not supported functions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDeviceObject\fP Device object\&. 
.br
\fIIrp\fP Irp object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
STATUS_NOT_SUPPORTED always\&. 
.RE
.PP

.PP
Definition at line 360 of file dioport\&.c\&.
.SS "VOID DioDriverUnload (IN PDRIVER_OBJECT DriverObject)"

.PP
Dispatch routine for DriverUnload\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDriverObject\fP Driver object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Definition at line 547 of file dioport\&.c\&.
.SS "BOOLEAN DioForceUnregister (IN HANDLE UnregisterProcessId)"

.PP
Forcibly unregisters specified process\&. 
.PP
\fBParameters:\fP
.RS 4
\fIUnregisterProcessId\fP Process id to unregister\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Non-zero if successful\&. 
.RE
.PP

.PP
Definition at line 276 of file dioport\&.c\&.
.SS "VOID DiopCreateProcessNotifyRoutine (IN HANDLE ParentId, IN HANDLE ProcessId, IN BOOLEAN Create)"

.PP
Our process notify routine\&. This function is reserved for internal use\&.
.PP
\fBParameters:\fP
.RS 4
\fIParentId\fP ID of parent process\&. 
.br
\fIProcessId\fP ID of target process\&. 
.br
\fICreate\fP Zero for process deletion\&. Other values for process creation\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Definition at line 330 of file dioport\&.c\&.
.SS "VOID DiopSetIoAccessMap (IN \fBDIO_PORTACCESS_ENTRY\fP * PortAccessEntry, IN \fBIO_ACCESS_MAP\fP * AccessMap, IN BOOLEAN DenyAccess)"

.PP
Sets the I/O access map\&. This function is reserved for internal use\&.
.PP
\fBParameters:\fP
.RS 4
\fIPortAccessEntry\fP Address of port access entry\&. 
.br
\fIAccessMap\fP Access map to modify\&. 
.br
\fIDenyAccess\fP If this value is non-zero, port access will be denied\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Definition at line 103 of file dioport\&.c\&.
.SS "BOOLEAN DiopValidatePacketBuffer (IN \fBDIO_PACKET\fP * Packet, IN ULONG InputBufferLength, IN ULONG IoControlCode)"

.PP
Validates the packet buffer\&. This function is reserved for internal use\&.
.PP
\fBParameters:\fP
.RS 4
\fIPacket\fP Address of packet buffer\&. 
.br
\fIInputBufferLength\fP Length of packet buffer\&. 
.br
\fIIoControlCode\fP Related IOCTL code of packet buffer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Non-zero if successful\&. 
.RE
.PP

.PP
Definition at line 57 of file dioport\&.c\&.
.SS "BOOLEAN DioRegisterSelf (VOID)"

.PP
Registers caller process to permit port I/O access\&. 
.PP
\fBReturns:\fP
.RS 4
Non-zero if successful\&. 
.RE
.PP

.PP
Definition at line 217 of file dioport\&.c\&.
.SS "BOOLEAN DioSetIoAccessMapByPacket (IN OPTIONAL \fBDIO_PACKET_PORTACCESS\fP * PortAccess, IN \fBIO_ACCESS_MAP\fP * AccessMap)"

.PP
Enables port I/O access for specified address range\&. 
.PP
\fBParameters:\fP
.RS 4
\fIPortAccess\fP Address of packet\&. 
.br
\fIAccessMap\fP Access map to modify\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Non-zero if successful\&. 
.RE
.PP

.PP
Definition at line 174 of file dioport\&.c\&.
.SS "BOOLEAN DioUnregister (IN BOOLEAN DisableIoAccess)"

.PP
Unregisters caller process to permit port I/O access\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDisableIoAccess\fP If this value is non-zero, port I/O access will be disabled\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Non-zero if successful\&. 
.RE
.PP

.PP
Definition at line 246 of file dioport\&.c\&.
.SS "NTSTATUS DriverEntry (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)"

.PP
Driver start entry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDriverObject\fP Driver object\&. 
.br
\fIRegistryPath\fP Registry path for driver services\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
STATUS_SUCCESS if successful\&. 
.RE
.PP

.PP
Definition at line 583 of file dioport\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "\fBDIO_PORTACCESS_ENTRY\fP DiopConventionalPortAccessListForDeny[]"
\fBInitial value:\fP
.PP
.nf
= {
    { 0x0000, 0x6fff }, 
    
    { 0x7080, 0xffff }, 
}
.fi
.PP
Definition at line 44 of file dioport\&.c\&.
.SS "UNICODE_STRING DiopDeviceName"

.PP
Definition at line 35 of file dioport\&.c\&.
.SS "PDEVICE_OBJECT DiopDeviceObject = NULL"

.PP
Definition at line 33 of file dioport\&.c\&.
.SS "UNICODE_STRING DiopDosDeviceName"

.PP
Definition at line 36 of file dioport\&.c\&.
.SS "PDRIVER_OBJECT DiopDriverObject = NULL"

.PP
Definition at line 32 of file dioport\&.c\&.
.SS "KSPIN_LOCK DiopForceUnregisterLock"

.PP
Definition at line 40 of file dioport\&.c\&.
.SS "\fBIO_ACCESS_MAP\fP* DiopIoAccessMap = NULL"

.PP
Definition at line 38 of file dioport\&.c\&.
.SS "volatile PEPROCESS DiopRegisteredProcess = NULL"

.PP
Definition at line 41 of file dioport\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for DIO from the source code\&.
